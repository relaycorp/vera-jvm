package tech.relaycorp.veraid.utils.x509

import io.kotest.matchers.comparables.shouldBeGreaterThan
import io.kotest.matchers.date.shouldBeBefore
import io.kotest.matchers.date.shouldNotBeBefore
import io.kotest.matchers.should
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.types.beInstanceOf
import org.bouncycastle.asn1.ASN1ObjectIdentifier
import org.bouncycastle.asn1.DERBMPString
import org.bouncycastle.asn1.DERNull
import org.bouncycastle.asn1.DLTaggedObject
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x500.X500NameBuilder
import org.bouncycastle.asn1.x500.style.BCStyle
import org.bouncycastle.asn1.x509.AuthorityKeyIdentifier
import org.bouncycastle.asn1.x509.BasicConstraints
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.asn1.x509.SubjectKeyIdentifier
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo
import org.bouncycastle.cert.X509CertificateHolder
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder
import org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import tech.relaycorp.veraid.pki.generateRSAKeyPair
import tech.relaycorp.veraid.utils.BC_PROVIDER
import tech.relaycorp.veraid.utils.generateRandomBigInteger
import tech.relaycorp.veraid.utils.issueStubCertificate
import tech.relaycorp.veraid.utils.sha256
import java.io.IOException
import java.math.BigInteger
import java.security.InvalidAlgorithmParameterException
import java.security.PrivateKey
import java.security.PublicKey
import java.security.cert.CertPathBuilderException
import java.time.Instant
import java.time.LocalDateTime
import java.time.ZoneOffset.UTC
import java.time.ZonedDateTime
import java.time.temporal.ChronoUnit
import java.util.Date

class CertificateTest {
    private val subjectCommonName = "The CommonName"
    private val subjectKeyPair = generateRSAKeyPair()
    private val validityEndDate = ZonedDateTime.now().plusMonths(2)

    private val issuerKeyPair = generateRSAKeyPair()

    @Nested
    inner class Issue {
        @Test
        fun `Certificate version should be 3`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            certificate.certificateHolder.versionNumber shouldBe 3
        }

        @Test
        fun `Subject public key should be the specified one`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            certificate.subjectPublicKey shouldBe subjectKeyPair.public
        }

        @Test
        fun `Certificate should be signed with issuer private key`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            val verifierProvider = JcaContentVerifierProviderBuilder()
                .setProvider(BC_PROVIDER)
                .build(subjectKeyPair.public)
            certificate.certificateHolder.isSignatureValid(verifierProvider) shouldBe true
        }

        @Test
        fun `Certificate should be signed with RSA-PSS`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            certificate.certificateHolder.signatureAlgorithm.algorithm shouldBe
                PKCSObjectIdentifiers.id_RSASSA_PSS
        }

        @Test
        fun `Serial number should be autogenerated`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            certificate.certificateHolder.serialNumber shouldBeGreaterThan BigInteger.ZERO
        }

        @Test
        fun `Validity start date should be set to current UTC time by default`() {
            val beforeInstant = Instant.now().truncatedTo(ChronoUnit.SECONDS)

            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            val afterInstant = Instant.now()
            val startDate = certificate.certificateHolder.notBefore.toInstant()
            startDate shouldNotBeBefore beforeInstant
            startDate shouldBeBefore afterInstant
        }

        @Nested
        inner class ValidityEndDate {
            @Test
            fun `End date should be honored`() {
                val endZonedDate = ZonedDateTime.now().plusDays(1).truncatedTo(ChronoUnit.SECONDS)
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    endZonedDate,
                )

                certificate.certificateHolder.notAfter.toInstant() shouldBe endZonedDate.toInstant()
            }

            @Test
            fun `End date should be later than the start date`() {
                val validityStartDate = ZonedDateTime.now().plusMonths(1)

                val exception = assertThrows<CertificateException> {
                    Certificate.issue(
                        subjectCommonName,
                        subjectKeyPair.public,
                        subjectKeyPair.private,
                        validityStartDate,
                        validityStartDate = validityStartDate, // Same as start date
                    )
                }
                exception.message shouldBe "The end date must be later than the start date"
            }

            @Test
            fun `End date should be capped at that of issuer`() {
                val issuerCertificate = Certificate.issue(
                    "the issuer",
                    issuerKeyPair.public,
                    issuerKeyPair.private,
                    validityEndDate,
                    isCA = true,
                )
                val subjectCertificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate.plusSeconds(1),
                    issuerCertificate,
                )

                subjectCertificate.expiryDate shouldBe issuerCertificate.expiryDate
            }

            @Test
            fun `Issuer end date should be after subject start date`() {
                val issuerCertificate = Certificate.issue(
                    "the issuer",
                    issuerKeyPair.public,
                    issuerKeyPair.private,
                    validityEndDate,
                    isCA = true,
                )
                val validityStartDate = issuerCertificate.expiryDate.plusSeconds(1)

                val exception = assertThrows<CertificateException> {
                    Certificate.issue(
                        subjectCommonName,
                        subjectKeyPair.public,
                        subjectKeyPair.private,
                        validityStartDate.plusSeconds(1),
                        issuerCertificate,
                        validityStartDate = validityStartDate,
                    )
                }
                exception.message shouldBe "The end date must be later than the start date"
            }
        }

        @Test
        fun `Subject DN should be set to specified CN`() {
            val commonName = "The CN"
            val certificate = Certificate.issue(
                commonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            val distinguishedNames = certificate.certificateHolder.subject.rdNs
            distinguishedNames.size shouldBe 1
            distinguishedNames[0].isMultiValued shouldBe false
            distinguishedNames[0].first.type shouldBe BCStyle.CN
            distinguishedNames[0].first.value should beInstanceOf<DERBMPString>()
            distinguishedNames[0].first.value.toString() shouldBe commonName
        }

        @Test
        fun `Issuer DN should be same as subject when certificate is self-issued`() {
            val commonName = "The CN"
            val certificate = Certificate.issue(
                commonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            val distinguishedNames = certificate.certificateHolder.issuer.rdNs
            distinguishedNames.size shouldBe 1
            distinguishedNames[0].isMultiValued shouldBe false
            distinguishedNames[0].first.type shouldBe BCStyle.CN
            distinguishedNames[0].first.value.toString() shouldBe commonName
        }

        @Nested
        inner class IssuerCertificate {
            @Test
            fun `Issuer DN should be set to subject of issuer certificate`() {
                // Use an intermediate CA as the issuer because its subject and issuer would be
                // different. If we use a root/self-signed CA, its subject and issuer would be
                // the same, which would make it hard to see why the test passed.
                val rootCAKeyPair = generateRSAKeyPair()
                val rootCACert = Certificate.issue(
                    "root",
                    rootCAKeyPair.public,
                    rootCAKeyPair.private,
                    validityEndDate,
                    isCA = true,
                    pathLenConstraint = 1,
                )
                val issuerCommonName = "The issuer"
                val issuerCertificate = Certificate.issue(
                    issuerCommonName,
                    issuerKeyPair.public,
                    issuerKeyPair.private,
                    validityEndDate,
                    rootCACert,
                    isCA = true,
                )
                val subjectCertificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    issuerKeyPair.private,
                    validityEndDate,
                    issuerCertificate = issuerCertificate,
                )

                subjectCertificate.certificateHolder.issuer.rdNs.size shouldBe 1
                val name = subjectCertificate.certificateHolder.issuer.rdNs[0]
                name.isMultiValued shouldBe false
                name.first.value.toString() shouldBe issuerCommonName
            }

            @Test
            fun `Issuer certificate should have basicConstraints extension`() {
                val issuerCertificate = issueCertWithoutBasicConstraints(
                    issuerKeyPair.public,
                    issuerKeyPair.private,
                )

                val exception = assertThrows<CertificateException> {
                    Certificate.issue(
                        subjectCommonName,
                        subjectKeyPair.public,
                        issuerKeyPair.private,
                        validityEndDate,
                        issuerCertificate = issuerCertificate,
                    )
                }

                exception.message shouldBe "Issuer certificate should be marked as CA"
            }

            @Test
            fun `Issuer certificate should be marked as CA`() {
                val issuerCommonName = "The issuer"
                val issuerCertificate = Certificate.issue(
                    issuerCommonName,
                    issuerKeyPair.public,
                    issuerKeyPair.private,
                    validityEndDate,
                    isCA = false,
                )
                val exception = assertThrows<CertificateException> {
                    Certificate.issue(
                        subjectCommonName,
                        subjectKeyPair.public,
                        issuerKeyPair.private,
                        validityEndDate,
                        issuerCertificate = issuerCertificate,
                    )
                }

                exception.message shouldBe "Issuer certificate should be marked as CA"
            }
        }

        @Nested
        inner class BasicConstraintsExtension {
            private val extensionOid = "2.5.29.19"

            @Test
            fun `Extension should be included and marked as critical`() {
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate,
                )

                certificate.certificateHolder.hasExtensions() shouldBe true
                val extension =
                    certificate.certificateHolder.getExtension(ASN1ObjectIdentifier(extensionOid))
                extension should beInstanceOf<Extension>()
                extension.isCritical shouldBe true
            }

            @Test
            fun `CA flag should be false by default`() {
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate,
                )

                val basicConstraints =
                    BasicConstraints.fromExtensions(certificate.certificateHolder.extensions)
                basicConstraints.isCA shouldBe false
            }

            @Test
            fun `CA flag should be enabled if requested`() {
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate,
                    isCA = true,
                )

                val basicConstraints =
                    BasicConstraints.fromExtensions(certificate.certificateHolder.extensions)
                basicConstraints.isCA shouldBe true
            }

            @Test
            fun `CA flag should be enabled if pathLenConstraint is greater than 0`() {
                val exception = assertThrows<CertificateException> {
                    Certificate.issue(
                        subjectCommonName,
                        subjectKeyPair.public,
                        subjectKeyPair.private,
                        validityEndDate,
                        isCA = false,
                        pathLenConstraint = 1,
                    )
                }

                exception.message shouldBe "Subject should be a CA if pathLenConstraint=1"
            }

            @Test
            fun `pathLenConstraint should be 0 by default`() {
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate,
                )

                val basicConstraints = BasicConstraints.fromExtensions(
                    certificate.certificateHolder.extensions,
                )
                basicConstraints.pathLenConstraint.toInt() shouldBe 0
            }

            @Test
            fun `pathLenConstraint can be set to a custom value of up to 2`() {
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate,
                    isCA = true,
                    pathLenConstraint = 2,
                )

                val basicConstraints = BasicConstraints.fromExtensions(
                    certificate.certificateHolder.extensions,
                )
                basicConstraints.pathLenConstraint.toInt() shouldBe 2
            }

            @Test
            fun `pathLenConstraint should not be greater than 2`() {
                val exception = assertThrows<CertificateException> {
                    Certificate.issue(
                        subjectCommonName,
                        subjectKeyPair.public,
                        subjectKeyPair.private,
                        validityEndDate,
                        pathLenConstraint = 3,
                    )
                }

                exception.message shouldBe "pathLenConstraint should be between 0 and 2 (got 3)"
            }

            @Test
            fun `pathLenConstraint should not be negative`() {
                val exception = assertThrows<CertificateException> {
                    Certificate.issue(
                        subjectCommonName,
                        subjectKeyPair.public,
                        subjectKeyPair.private,
                        validityEndDate,
                        pathLenConstraint = -1,
                    )
                }

                exception.message shouldBe "pathLenConstraint should be between 0 and 2 (got -1)"
            }
        }

        @Nested
        inner class AuthorityKeyIdentifierTest {
            private val issuerKeyPair = generateRSAKeyPair()
            private val issuerCertificate = Certificate.issue(
                subjectCommonName,
                issuerKeyPair.public,
                issuerKeyPair.private,
                validityEndDate,
                isCA = true,
            )

            @Test
            fun `Value should correspond to subject when self-issued`() {
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate,
                )

                val aki = AuthorityKeyIdentifier.fromExtensions(
                    certificate.certificateHolder.extensions,
                )
                val subjectPublicKeyInfo = certificate.certificateHolder.subjectPublicKeyInfo
                aki.keyIdentifier shouldBe sha256(subjectPublicKeyInfo.encoded)
            }

            @Test
            fun `Issuer should be refused if it does not have an SKI`() {
                val issuerDistinguishedName = X500Name("CN=issuer")
                val subjectPublicKeyInfo =
                    SubjectPublicKeyInfo.getInstance(issuerKeyPair.public.encoded)
                val builder = X509v3CertificateBuilder(
                    issuerDistinguishedName,
                    generateRandomBigInteger(),
                    Date.from(ZonedDateTime.now().toInstant()),
                    Date.from(validityEndDate.toInstant()),
                    issuerDistinguishedName,
                    subjectPublicKeyInfo,
                )
                val basicConstraints = BasicConstraintsExtension(true, 0)
                builder.addExtension(Extension.basicConstraints, true, basicConstraints)
                val signer = JcaContentSignerBuilder("SHA256WITHRSAANDMGF1")
                    .setProvider(BC_PROVIDER)
                    .build(issuerKeyPair.private)
                val issuerWithoutSKI = Certificate(builder.build(signer))

                val exception = assertThrows<CertificateException> {
                    Certificate.issue(
                        subjectCommonName,
                        subjectKeyPair.public,
                        issuerKeyPair.private,
                        validityEndDate,
                        issuerCertificate = issuerWithoutSKI,
                    )
                }

                exception.message shouldBe "Issuer must have the SubjectKeyIdentifier extension"
            }

            @Test
            fun `Value should correspond to issuer when issued by a CA`() {
                val subjectCertificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate,
                    issuerCertificate = issuerCertificate,
                )

                val issuerPublicKeyInfo = issuerCertificate.certificateHolder.subjectPublicKeyInfo
                val aki = AuthorityKeyIdentifier.fromExtensions(
                    subjectCertificate.certificateHolder.extensions,
                )
                aki.keyIdentifier shouldBe sha256(issuerPublicKeyInfo.encoded)
            }
        }

        @Test
        fun `Subject Key Identifier extension should be SHA-256 digest of subject key`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            val ski = SubjectKeyIdentifier.fromExtensions(
                certificate.certificateHolder.extensions,
            )
            val subjectPublicKeyInfo = certificate.certificateHolder.subjectPublicKeyInfo
            ski.keyIdentifier shouldBe sha256(subjectPublicKeyInfo.encoded)
        }
    }

    @Nested
    inner class Serialise {
        @Test
        fun `Output should be DER-encoded`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            val certificateSerialized = certificate.serialise()

            val certificateHolderDeserialized = X509CertificateHolder(certificateSerialized)
            certificateHolderDeserialized shouldBe certificate.certificateHolder
        }
    }

    @Nested
    inner class Deserialise {
        @Test
        fun `Valid certificates should be parsed`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )
            val certificateSerialized = certificate.serialise()

            val certificateDeserialized = Certificate.deserialise(certificateSerialized)

            certificateDeserialized shouldBe certificate
        }

        @Test
        fun `Invalid certificates should result in errors`() {
            val exception = assertThrows<CertificateException> {
                Certificate.deserialise("Not a certificate".toByteArray())
            }

            exception.message shouldBe "Value should be a DER-encoded, X.509 v3 certificate"
            exception.cause should beInstanceOf<IOException>()
        }
    }

    @Nested
    inner class Encode {
        @Test
        fun `Output should be ASN1 encoded`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            val certificateEncoded = certificate.encode()

            val certificateHolder = X509CertificateHolder(certificateEncoded)
            certificateHolder shouldBe certificate.certificateHolder
        }
    }

    @Nested
    inner class Decode {
        @Test
        fun `Valid certificates should be parsed`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )
            val certificateEncoded = DLTaggedObject(false, 1, certificate.encode())

            val certificateDeserialized = Certificate.decode(certificateEncoded)

            certificateDeserialized shouldBe certificate
        }

        @Test
        fun `Valid yet explicitly-tagged certificates should result in errors`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )
            val certificateEncoded = DLTaggedObject(true, 1, certificate.encode())

            val exception = assertThrows<CertificateException> {
                Certificate.decode(certificateEncoded)
            }

            exception.message shouldBe "ASN.1 value is not an X.509 v3 certificate"
            exception.cause should beInstanceOf<IllegalStateException>()
        }

        @Test
        fun `Invalid certificates should result in errors`() {
            val exception = assertThrows<CertificateException> {
                Certificate.decode(DLTaggedObject(false, 0, DERNull.INSTANCE))
            }

            exception.message shouldBe "ASN.1 value is not an X.509 v3 certificate"
            exception.cause should beInstanceOf<IllegalStateException>()
        }
    }

    @Nested
    inner class Properties {
        @Test
        fun commonName() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            certificate.commonName shouldBe subjectCommonName
        }

        @Test
        fun startDate() {
            val startDate = ZonedDateTime.now()
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
                validityStartDate = startDate,
            )

            certificate.startDate shouldBe startDate.withNano(0)
        }

        @Test
        fun expiryDate() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            certificate.expiryDate shouldBe validityEndDate.withNano(0)
        }

        @Test
        fun subjectPublicKey() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            certificate.subjectPublicKey.encoded shouldBe subjectKeyPair.public.encoded
        }

        @Test
        fun issuerCommonName() {
            val issuerKeyPair = generateRSAKeyPair()
            val issuerCertificate = issueStubCertificate(
                issuerKeyPair.public,
                issuerKeyPair.private,
                isCA = true,
            )
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                issuerKeyPair.private,
                validityEndDate,
                issuerCertificate,
            )

            certificate.issuerCommonName shouldBe issuerCertificate.commonName
        }
    }

    @Nested
    inner class Equals {
        private val stubCertificate = Certificate.issue(
            subjectCommonName,
            subjectKeyPair.public,
            subjectKeyPair.private,
            validityEndDate,
        )

        @Test
        fun `A null value should not equal`() {
            stubCertificate.equals(null) shouldBe false
        }

        @Test
        fun `A non-Certificate object should not equal`() {
            stubCertificate shouldNotBe "Hey"
        }

        @Test
        fun `A different certificate should not equal`() {
            val anotherKeyPair = generateRSAKeyPair()
            val anotherCertificate = Certificate.issue(
                subjectCommonName,
                anotherKeyPair.public,
                anotherKeyPair.private,
                validityEndDate,
            )

            anotherCertificate shouldNotBe stubCertificate
        }

        @Test
        fun `An equivalent certificate of the same class should equal`() {
            val sameCertificate = Certificate(stubCertificate.certificateHolder)
            sameCertificate shouldBe stubCertificate
        }

        @Test
        fun `An equivalent certificate of a different class should not equal`() {
            val certificate1 = Certificate(stubCertificate.certificateHolder)
            val certificate2 = object : Certificate(stubCertificate.certificateHolder) {
                // This is a subclass
            }
            certificate1 shouldNotBe certificate2
        }
    }

    @Nested
    inner class HashCode {
        @Test
        fun `Hashcode should be that of certificate holder`() {
            val stubCertificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            stubCertificate.hashCode() shouldBe stubCertificate.certificateHolder.hashCode()
        }
    }

    @Nested
    inner class Validate {
        @Nested
        inner class ValidityPeriod {
            @Test
            fun `Start date in the future should be refused`() {
                val startDate = ZonedDateTime.now().plusSeconds(2)
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate,
                    validityStartDate = startDate,
                )

                val exception = assertThrows<CertificateException> { certificate.validate() }

                exception.message shouldBe "Certificate is not yet valid"
            }

            @Test
            fun `Expiry date in the past should be refused`() {
                val startDate = ZonedDateTime.now().minusSeconds(2)
                val endDate = startDate.plusSeconds(1)
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    endDate,
                    validityStartDate = startDate,
                )

                val exception = assertThrows<CertificateException> { certificate.validate() }

                exception.message shouldBe "Certificate already expired"
            }

            @Test
            fun `Start date in the past and end date in the future should be accepted`() {
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate,
                )

                certificate.validate()
            }
        }

        @Nested
        inner class CommonName {
            @Test
            fun `Validation should fail if Common Name is missing`() {
                val issuerDistinguishedNameBuilder = X500NameBuilder(BCStyle.INSTANCE)
                issuerDistinguishedNameBuilder.addRDN(BCStyle.C, "GB")
                val builder = X509v3CertificateBuilder(
                    issuerDistinguishedNameBuilder.build(),
                    42.toBigInteger(),
                    Date.from(ZonedDateTime.now().toInstant()),
                    Date.from(validityEndDate.plusMonths(1).toInstant()),
                    issuerDistinguishedNameBuilder.build(),
                    SubjectPublicKeyInfo.getInstance(subjectKeyPair.public.encoded),
                )
                val signer = JcaContentSignerBuilder("SHA256WITHRSAANDMGF1")
                    .setProvider(BC_PROVIDER)
                    .build(subjectKeyPair.private)
                val invalidCertificate = Certificate(builder.build(signer))

                val exception = assertThrows<CertificateException> {
                    invalidCertificate.validate()
                }

                exception.message shouldBe "Subject should have a Common Name"
            }

            @Test
            fun `Validation should pass if Common Name is present`() {
                val certificate = Certificate.issue(
                    subjectCommonName,
                    subjectKeyPair.public,
                    subjectKeyPair.private,
                    validityEndDate,
                )

                certificate.validate()
            }
        }
    }

    @Nested
    inner class IsLikelyIssuer {
        @Test
        fun `False should be returned if DN doesn't match`() {
            val certificate1 = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )
            val certificate2 = Certificate.issue(
                "not-$subjectCommonName",
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            certificate1.isLikelyIssuer(certificate2) shouldBe false
        }

        @Test
        fun `True should be returned if DN matches`() {
            val certificate = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            certificate.isLikelyIssuer(certificate) shouldBe true
        }
    }

    @Nested
    inner class GetCertificationPath {
        private val rootCACert = Certificate.issue(
            subjectCommonName,
            subjectKeyPair.public,
            subjectKeyPair.private,
            validityEndDate,
            isCA = true,
            pathLenConstraint = 2,
        )

        @Test
        fun `Certificate self-issued by trusted CA should be trusted`() {
            val certPath = rootCACert.getCertificationPath(emptySet(), setOf(rootCACert))

            certPath shouldBe listOf(rootCACert)
        }

        @Test
        fun `Cert issued by trusted CA should be trusted`() {
            val endEntityKeyPair = generateRSAKeyPair()
            val endEntityCert = issueStubCertificate(
                endEntityKeyPair.public,
                subjectKeyPair.private,
                rootCACert,
            )

            val certPath = endEntityCert.getCertificationPath(emptySet(), setOf(rootCACert))

            certPath shouldBe listOf(endEntityCert, rootCACert)
        }

        @Test
        fun `Cert not issued by trusted cert should not be trusted`() {
            val endEntityKeyPair = generateRSAKeyPair()
            val endEntityCert =
                issueStubCertificate(endEntityKeyPair.public, endEntityKeyPair.private)

            val exception = assertThrows<CertificateException> {
                endEntityCert.getCertificationPath(emptySet(), setOf(rootCACert))
            }

            exception.message shouldBe "No certification path could be found"
            exception.cause should beInstanceOf<CertPathBuilderException>()
        }

        @Test
        fun `Cert issued by untrusted intermediate CA should be trusted if root is trusted`() {
            val intermediateCAKeyPair = generateRSAKeyPair()
            val intermediateCACert = issueStubCertificate(
                intermediateCAKeyPair.public,
                subjectKeyPair.private,
                rootCACert,
                isCA = true,
            )
            val endEntityKeyPair = generateRSAKeyPair()
            val endEntityCert = issueStubCertificate(
                endEntityKeyPair.public,
                intermediateCAKeyPair.private,
                intermediateCACert,
            )

            val certPath =
                endEntityCert.getCertificationPath(setOf(intermediateCACert), setOf(rootCACert))

            certPath shouldBe listOf(endEntityCert, intermediateCACert, rootCACert)
        }

        @Test
        fun `Valid paths may have multiple untrusted intermediate CA`() {
            val intermediateCA1KeyPair = generateRSAKeyPair()
            val intermediateCA1Cert = Certificate.issue(
                "intermediate1",
                intermediateCA1KeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
                rootCACert,
                true,
                1,
            )
            val intermediateCA2KeyPair = generateRSAKeyPair()
            val intermediateCA2Cert = Certificate.issue(
                "intermediate2",
                intermediateCA2KeyPair.public,
                intermediateCA1KeyPair.private,
                validityEndDate,
                intermediateCA1Cert,
                true,
            )
            val endEntityKeyPair = generateRSAKeyPair()
            val endEntityCert = Certificate.issue(
                "end",
                endEntityKeyPair.public,
                intermediateCA2KeyPair.private,
                validityEndDate,
                intermediateCA2Cert,
            )

            val certPath = endEntityCert.getCertificationPath(
                setOf(intermediateCA1Cert, intermediateCA2Cert),
                setOf(rootCACert),
            )

            listOf(
                endEntityCert,
                intermediateCA2Cert,
                intermediateCA1Cert,
                rootCACert,
            ) shouldBe certPath
        }

        @Test
        fun `Cert issued by trusted intermediate CA should be trusted`() {
            val intermediateCAKeyPair = generateRSAKeyPair()
            val intermediateCACert = issueStubCertificate(
                intermediateCAKeyPair.public,
                subjectKeyPair.private,
                rootCACert,
                isCA = true,
            )
            val endEntityKeyPair = generateRSAKeyPair()
            val endEntityCert = issueStubCertificate(
                endEntityKeyPair.public,
                intermediateCAKeyPair.private,
                intermediateCACert,
            )

            val certPath =
                endEntityCert.getCertificationPath(emptySet(), setOf(intermediateCACert))

            certPath shouldBe listOf(endEntityCert, intermediateCACert)
        }

        @Test
        fun `Cert issued by untrusted intermediate CA should not be trusted`() {
            val intermediateCAKeyPair = generateRSAKeyPair()
            val intermediateCACert = issueStubCertificate(
                intermediateCAKeyPair.public,
                intermediateCAKeyPair.private,
                isCA = true,
            )
            val endEntityKeyPair = generateRSAKeyPair()
            val endEntityCert = issueStubCertificate(
                endEntityKeyPair.public,
                endEntityKeyPair.private,
                intermediateCACert,
            )

            val exception = assertThrows<CertificateException> {
                endEntityCert.getCertificationPath(setOf(intermediateCACert), setOf(rootCACert))
            }

            exception.message shouldBe "No certification path could be found"
        }

        @Test
        fun `Including trusted intermediate CA should not make certificate trusted`() {
            val intermediateCAKeyPair = generateRSAKeyPair()
            val intermediateCACert = issueStubCertificate(
                intermediateCAKeyPair.public,
                intermediateCAKeyPair.private,
                isCA = true,
            )
            val endEntityKeyPair = generateRSAKeyPair()
            val endEntityCert = issueStubCertificate(
                endEntityKeyPair.public,
                endEntityKeyPair.private,
                intermediateCACert,
            )

            val exception = assertThrows<CertificateException> {
                endEntityCert.getCertificationPath(
                    setOf(rootCACert, intermediateCACert),
                    setOf(rootCACert),
                )
            }

            exception.message shouldBe "No certification path could be found"
        }

        @Test
        fun `Root CA in path should be identified when there are multiple trusted CAs`() {
            // Java doesn't include the trusted CA in the path, so we have to include it
            // ourselves. Let's make sure we do it properly.
            val trustedCA2KeyPair = generateRSAKeyPair()
            val trustedCA2Cert = issueStubCertificate(
                trustedCA2KeyPair.public,
                trustedCA2KeyPair.private,
                isCA = true,
            )

            val intermediateCAKeyPair = generateRSAKeyPair()
            val intermediateCACert = issueStubCertificate(
                intermediateCAKeyPair.public,
                subjectKeyPair.private,
                rootCACert,
                isCA = true,
            )
            val endEntityKeyPair = generateRSAKeyPair()
            val endEntityCert = issueStubCertificate(
                endEntityKeyPair.public,
                intermediateCAKeyPair.private,
                intermediateCACert,
            )

            val certPath = endEntityCert.getCertificationPath(
                setOf(intermediateCACert),
                setOf(trustedCA2Cert, rootCACert),
            )

            certPath shouldBe listOf(endEntityCert, intermediateCACert, rootCACert)
        }

        @Test
        fun `The exact same instance of the certificates should be returned`() {
            val intermediateCAKeyPair = generateRSAKeyPair()
            val intermediateCACert = issueStubCertificate(
                intermediateCAKeyPair.public,
                subjectKeyPair.private,
                rootCACert,
                isCA = true,
            )
            val endEntityKeyPair = generateRSAKeyPair()
            val endEntityCert = issueStubCertificate(
                endEntityKeyPair.public,
                intermediateCAKeyPair.private,
                intermediateCACert,
            )

            val certPath =
                endEntityCert.getCertificationPath(setOf(intermediateCACert), setOf(rootCACert))

            certPath.size shouldBe 3
            certPath.first() shouldBe endEntityCert
            certPath[1] shouldBe intermediateCACert
            certPath.last() shouldBe rootCACert
        }

        @Test
        fun `An empty set of trusted CAs will fail validation`() {
            val endEntityKeyPair = generateRSAKeyPair()
            val endEntityCert = issueStubCertificate(
                endEntityKeyPair.public,
                subjectKeyPair.private,
                rootCACert,
            )

            val exception = assertThrows<CertificateException> {
                endEntityCert.getCertificationPath(emptySet(), emptySet())
            }

            exception.message shouldBe
                "Failed to initialize path builder; set of trusted CAs might be empty"
            exception.cause should beInstanceOf<InvalidAlgorithmParameterException>()
        }
    }

    @Nested
    inner class IsCA {
        @Test
        fun `True should be returned if entity is CA`() {
            val cert = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
                isCA = true,
            )

            cert.isCA shouldBe true
        }

        @Test
        fun `False should be returned if entity is not CA`() {
            val cert = Certificate.issue(
                subjectCommonName,
                subjectKeyPair.public,
                subjectKeyPair.private,
                validityEndDate,
            )

            cert.isCA shouldBe false
        }

        @Test
        fun `False should be returned if BasicConstrains extension is missing`() {
            val cert = issueCertWithoutBasicConstraints(
                subjectKeyPair.public,
                subjectKeyPair.private,
            )

            cert.isCA shouldBe false
        }
    }

    private fun issueCertWithoutBasicConstraints(
        publicKey: PublicKey,
        privateKey: PrivateKey,
    ): Certificate {
        val issuerCommonName = "The issuer"
        val issuerDistinguishedNameBuilder = X500NameBuilder(BCStyle.INSTANCE)
        issuerDistinguishedNameBuilder.addRDN(BCStyle.CN, issuerCommonName)

        val builder = X509v3CertificateBuilder(
            issuerDistinguishedNameBuilder.build(),
            42.toBigInteger(),
            Date.from(LocalDateTime.now().toInstant(UTC)),
            Date.from(LocalDateTime.now().plusMonths(1).toInstant(UTC)),
            issuerDistinguishedNameBuilder.build(),
            SubjectPublicKeyInfo.getInstance(publicKey.encoded),
        )
        val signer = JcaContentSignerBuilder("SHA256WITHRSAANDMGF1")
            .setProvider(BC_PROVIDER)
            .build(privateKey)
        return Certificate(builder.build(signer))
    }
}
